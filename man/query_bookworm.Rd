% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bookworm.R
\name{query_bookworm}
\alias{query_bookworm}
\title{Queries the HathiTrust Bookworm Server at
https://bookworm.htrc.illinois.edu/develop/}
\usage{
query_bookworm(
  word,
  groups = "date_year",
  words_collation = "Case_Insensitive",
  counttype = "WordsPerMillion",
  method = "return_json",
  lims = c(1920, 2000),
  as_json = FALSE,
  ...
)
}
\arguments{
\item{word}{At least one term to get frequencies for. Can be a vector of
strings.}

\item{groups}{At least one category to group results by. The default is
\code{date_year}, which groups results by year.}

\item{words_collation}{Whether to use case-sensitive (\code{"Case_Sensitive"}) or
case-insensitive (\code{"Case_Insensitive"}, the default) matching. Can also be
\code{stem} to return word results for word stems. See the \href{https://bookworm-project.github.io/Docs/query_structure.html}{Bookworm API documentation}
for details.}

\item{counttype}{The default is words per million, \code{counttype = "WordsPerMillion"}. According to the \href{https://bookworm-project.github.io/Docs/query_structure.html}{API documentation},
the following options are available:

\code{WordCount}: The number of words matching the terms in \code{search_limits} for
each group. (If no \code{words} key is specified, the sum of all the words in
the book).

\code{TextCount}: The number of texts matching the constraints on
\code{search_limits} for each group.

\code{WordsPerMillion}: The number of words in the \code{search_limits} per million
words in the broader set. (Words per million, rather than percent, gives a
more legible number).

\code{TextPercent}: The percentage of texts in the broader group matching the
search terms.

\code{TotalTexts}: The number of texts matching the constraints on
\code{compare_limits}. (By selecting \code{TextCount} and \code{TotalTexts}, you can
derive \code{TextPercent} locally, if you prefer).

\code{TotalWords}: The number of words in the larger set.

\code{WordsRatio}: equal to \code{WordCount/TotalWords}. Useful when \code{method = "search_results"}.

\code{SumWords}: equal to \code{TotalWords + WordCount}

\code{TextRatio}: equal to \code{TextCount/TotalTexts}

\code{SumTexts}: equal to \code{TextCount + TotalTexts}}

\item{method}{Type of results to return. Can be \code{return_json} (the default -
automatically converted to a proper tibble when possible; the JSON is
structured as "nested dicts for each grouping in \code{groups} pointing to an
array consisting of the results for each count in \code{counttype}", according
to the \href{https://bookworm-project.github.io/Docs/query_structure.html}{API documentation}.),
\code{returnPossibleFields} (metadata fields available to use in \code{groups}), and
\code{search_results} (a list of books and HathiTrust URLs matching a query).
Note that \code{search_results} has a limit of 100 books at the moment, randomly
selected. Notes:
\itemize{
\item When using \code{returnPossibleFields} all other fields are ignored.
\item When using \code{search_results} only the first 100 results are returned,
sorted by the percentage of hits in the text. That biases towards either
texts that use the words a lot, or texts that use it rarely. It is possible
to use \code{counttype = "WordsRatio"} to return a list sorted randomly,
weighted by the number of times the word appears in it. The \href{https://bookworm-project.github.io/Docs/query_structure.html}{API documentation}
notes that "this means that a random word from the first text should
represent a random usage from the overall sample. The current MySQL-python
implementation uses an approximation for this:
\code{LOG(1-RAND())/sum(main.count)} that should mimic a weighted random
ordering for most distributions, but in some cases it may not behave as
intended."
}}

\item{lims}{Min and max year as a two-element numeric vector. Default is
\code{c(1920, 2000)}.}

\item{as_json}{Whether to return the raw json. Useful for complex queries
where the function does not know how to return a \link{tibble}, or when you want
to use the raw json to produce a different data structure.}

\item{...}{Additional parameters passed to \code{build_json_query}}
}
\value{
A \link{tibble} whenver possible, otherwise json-formatted text.
}
\description{
Queries the HathiTrust Bookworm Server at
https://bookworm.htrc.illinois.edu/develop/
}
\examples{
\dontrun{
result <- query_bookworm(word = c("democracy", "monarchy"), lims = c(1760, 2000),
  counttype = c("WordsPerMillion", "TextPercent"))

result2 <- query_bookworm(word = "democracy", groups = c("date_year", "class"), lims = c(1900,2000))

result4 <- query_bookworm(word = c("democracy"), lims = c(1760, 2000), counttype = c("TotalTexts"),
  language = "English")

result5 <- query_bookworm(word = "democracy", groups = "date_year", date_year = "1941",
  class = "Education", method = "search_results")
}
}
